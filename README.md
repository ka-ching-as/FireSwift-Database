# FireSwift-Database
A framework containing extensions to the Firebase Realtime Database enabling the use of `Codable` Swift types.

## Usage

In the following example, assume that we have a type `Configuration` that conforms to `Codable`.

Instead of 
```
let handle = ref.observe(.value) { snapshot in
     // Check if snapshot exists
     // Custom parsing of snapshot value
     // Error handling
}
```
you can use the `Decodable` types directly with the Firebase API:

```
let handle = ref.observe(eventType: .value) { (result: DecodeResult<Configuration>) in
    if let configuration = result.value {
        // configuration is of type Configuration
    } else {
        // Error handling
    }
}
```

And similarly for `Encodable` values.
Instead of:
```
let configuration: Configuration = ...
// Custom serialization of configuration to `Any`
ref.setValue(configValue)
```
you can now just do:
```
let configuration: Configuration = ...
ref.setValue(configuration)
```

This abstraction is already pretty powerful, but we can do even better.
The library contains a generic `Path` abstraction that can be used to model a type-safe alternative to the stringly-typed paths used to build Firebase `Reference`s. And even further you can use the generic type parameter of the `Path` to 'bind' to the type of the `Codable` parameters.

The examples above can be improved by defining a 'schema' for your firebase structure as follows:
```
// Define the schema of your firebase structure:
extension Path where Element == Root {
    var configuration: Path<Configuration> {
        return Path.append(self, "configuratino")
    }
}
```

Using this, the type of the `result` can be inferred from the type of the `configPath`: 
```
let configPath = Path().configuration
let handle = database.observe(at: configPath) { result in
    if let configuration = result.value {
        // configuration is of type Configuration
    } else {
        // Error handling
    }
}
```
or
```
let configuration: Configuration = ...
database.setValue(at: configPath, value: configuration)
```

And you can do even more. The `Path` type can be used to distinguish between paths to values and paths to collections of values.

A collection path could look as follows:
```
extension Path where Element == Root {
    var users: Path<User>.Collection {
        return Path.append(self, "users")
    }
}
```
Using collection paths we can restrict ourselves from writing a single value to override the entire collection and instead only allow _adding_ values:
```
let usersPath = Path().users
let user: User = ...
database.addValue(to: usersPath, value: user)
```
Similarly we can restrict ourselves from observing a `.value` on a collection, but only allow observing the `.childAdded`,  `.childRemoved` and `.childChanged` events.
```
let handle = database.observe(eventType: .childAdded, at: usersPath) { result in
    if let user = result.value {
        // user is of type User
    } else {
        // Error handling
    }}
```

If you enjoy these concepts, I can recommend looking into `RxSwift` for which I have also created the `RxFireSwift-Database` framework. This unlocks even cooler abstractions. :-)


## Installation

### Using [Carthage](https://github.com/Carthage/Carthage)

**Tested with `carthage version`: `0.31.0`**

Add this to `Cartfile`

```
github "ka-ching/FireSwift-Database" ~> 0.1
```

```bash
$ carthage update
```

### Automatic code generation

Add automatic `Path` code generation to an Xcode scheme. Just add a new "Run Script Phase" with something in the line of:

```bash
cd $PROJECT_DIR
./Carthage/Checkouts/FireSwift-Database/GeneratePaths.swift UseSwiftyFirebase/Resources/chatrooms.json > UseSwiftyFirebase/Generated/ChatroomPaths.swift
```

If you add this phase before the `Compile Sources` step, you will always be using up-to-date paths generated by the latest version of the scheme defined in the .json input file.

## TODO

- [ ] A
- [ ] B

## License

[Apache licensed.](LICENSE)

## About

FireSwift-Database is maintained by Ka-ching.

